"""
CHIPS AND CIRCUITS
"""

from core import *
from data.config1 import width as WIDTH, height as HEIGHT, gates

DEPTH = 8
SURF = WIDTH * HEIGHT

"""
INITIALIZE GRAPH AND VISUALIZATION
"""

# Create graph and connect it.
g = Graph(WIDTH, HEIGHT, DEPTH, SURF)
connectGraph(g)

# Convert x-y coordinates of gates to their id and disconnect these vertices
# from the graph.
gateList = []
for c in gates:
    gateList.append(c[1] * WIDTH + c[0])
disconnectVertex(g, gateList)
for i in gateList:
    g.vertDict[i].gate = True


# Initialize visualization.
screen = draw.initGrid(WIDTH, HEIGHT)
grid = [[[0 for c in range(DEPTH)] for b in range(WIDTH)] for a in range(HEIGHT)]
# Color all gates bright red.
for i in gates:
    grid[i[1]][i[0]][0] = (255, 0, 0)

depth = 0 


"""
VARIABLES and STRINGS
"""

# Mark different paths with p
p = 0
# netlist with lengths of every path p
pathlen = []
# paths on every vertex
pathsvert = []
# amount paths on every vertex
totalpathsvert = []
# lijst met vertices waar de kortste pad over loopt
vertices_shortest_path = []
# Count found paths
f = 0
# Count costs total
c = 0
totalTime = 0

for i in range(SURF*DEPTH):
    pathsvert.append([])


"""
SOLVE
"""
solve(g,vertices_shortest_path)

for i in range(len(pathsvert)):
    totalpathsvert.append(len(pathsvert[i]))

# x returnt de index van de vertex waar de meeste paden over lopen
x = totalpathsvert.index(max(totalpathsvert))
# y is een lijst met de meeste paden die over vertex x lopen
y = pathsvert[x]
# z slaat de lengtes op van de paden die op de bepaalde vertex lopen
z = []
for i in y:
    z.append(pathlen[i])
# v returnt de lengte van de kortste pad
v = min(z)
# slaat de pad op die het kortst is 
index_shortest_path = z.index(v)
shortest_path = y[index_shortest_path]

for vertex in range(len(pathsvert)):
    for path in range(len(pathsvert[vertex])):
        if (shortest_path == pathsvert[vertex][path]):
            vertices_shortest_path.append(vertex)

"""
MESSAGES TO USER
"""

print '\nTotal time: ' + str(totalTime) + ' seconds.'
print '\nCosts algorithm: ' + str(c) + '.'
print '\nLength every path: ' + str(pathlen)
print '\nThe most paths are going over vertex: ' + str(x)
print '\nPaths over ' + str(x) + ': ' + str(y)
print '\nLengths paths over ' + str(x) + ': ' + str(z)
print '\nMin length: ' + str(v) + ' from path ' + str(shortest_path)
print '\nVertices shortest path: ' + str(vertices_shortest_path)
print '\nPaths on every vertex: ' + str(pathsvert)
print '\nTotal paths on every vertex: ' + str(totalpathsvert)
print '\nSuccesfully connected ' + str(f) + ' of ' + str(len(netlist)) + '\
 required paths.'
print '\nSize surface: ' + str(SURF) + '.'
print '\nShowing layer: ' + str(depth)


"""
HANDLE EVENTS
"""

# Wait for mouse click to close visualization or view other layer
while True:
    event = pygame.event.wait()
    if event.type == pygame.QUIT:
        pygame.quit()
    elif event.type == pygame.MOUSEBUTTONDOWN:
        # Visualize the layer up or down from current (left and right click
        # respectively).
        if event.button == 1:
            screen.fill([255,255,255])
            depth += 1
            draw.drawGrid(grid, screen, depth)
        if event.button == 3:
            screen.fill([255,255,255])
            depth -= 1
            draw.drawGrid(grid, screen, depth)
        print 'Showing layer: ' + str(depth)
